------------------------------------------------------------------------------------------------------------------------
The Get and Put Principle или PECS (Producer Extends Consumer Super)
------------------------------------------------------------------------------------------------------------------------
Особенность wildcard с верхней и нижней границей дает дополнительные фичи, связанные с безопасным использованием типов.
Из одного типа переменных можно только читать, в другой — только вписывать (исключением является
возможность записать null для extends и прочитать Object для super).

Чтобы было легче запомнить, когда какой wildcard использовать, существует принцип PECS — Producer Extends Consumer Super.
    - Если мы объявили wildcard с extends, то это producer. Он только «продюсирует», предоставляет элемент из контейнера,
      а сам ничего не принимает.
    - Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.

Рассмотрим использование Wildcard и принципа PECS на примере метода copy в классе java.util.Collections.

        public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        …
        }

Метод осуществляет копирование элементов из исходного списка src в список dest. src — объявлен с wildcard ? extends
и является продюсером, а dest — объявлен с wildcard ? super и является потребителем.
Учитывая ковариантность и контравариантность wildcard, можно скопировать элементы из списка ints в список nums:
        List<Number> nums = Arrays.<Number>asList(4.1F, 0.2F);
        List<Integer> ints = Arrays.asList(1,2);
        Collections.copy(nums, ints);


Если же мы по ошибке перепутаем параметры метода copy и попытаемся выполнить копирование из списка nums в список ints,
то компилятор не позволит нам это сделать:
        Collections.copy(ints, nums); // Compile-time error

------------------------------------------------------------------------------------------------------------------------
Если необходимо читать из контейнера, то используйте wildcard с верхней границей "? extends".
Если необходимо писать в контейнер, то используйте wildcard с нижней границей "? super".
Не используйте wildcard, если нужно производить и запись, и чтение.
------------------------------------------------------------------------------------------------------------------------
Joshua Bloch:
    - if a parameterized type represents a T producer, use <? extends T>
    - if a parameterized type represents a T consumer, use <? super T>
------------------------------------------------------------------------------------------------------------------------
какую гибкость этодаёт:

        Collections.max(List<Integer>, List<Number>);
        Collections.max(List<String>, List<Object>);
------------------------------------------------------------------------------------------------------------------------
