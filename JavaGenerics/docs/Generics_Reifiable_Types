------------------------------------------------------------------------------------------------------------------------
Reifiable(надежный, достоверный, безотказный) типы:

В Java мы говорим, что тип является reifiable, если информация о нем полностью доступна во время выполнения программы.
В reifiable типы входят:
    - Примитивные типы (int, long, boolean)
    - Непараметризованные (необобщенные) типы (String, Integer)
    - Параметризованные типы, параметры которых представлены в виде unbounded wildcard (неограниченных
      символов подстановки) (List<?>, Collection<?>)
    - Raw (несформированные) типы (List, ArrayList)
    - Массивы, компоненты которых — Reifiable типы (int[], Number[], List<?>[], List[)

Почему информация об одних типах доступна, а о других нет?
Дело в том, что из-за процесса затирания типов компилятором информация о некоторых типах может быть потеряна.
Если она потерялась, то такой тип будет уже не reifiable.
То есть она во время выполнения недоступна. Если доступна – соответственно, reifiable.

Решение не делать все обобщенные типы доступными во время выполнения — это одно из наиболее важных и противоречивых
проектных решений в системе типов Java. Так сделали, в первую очередь, для совместимости с существующим кодом.
За миграционную совместимость пришлось платить — полная доступность системы обобщенных типов во время выполнения невозможна.

Какие типы не являются reifiable:
    - Переменная типа (T)
    - Параметризованный тип с указанным типом параметра (List<Number> ArrayList<String>, List<List<String>>)
    - Параметризованный тип с указанной верхней или нижней границей (List<? extends Number>, Comparable<? super String>).
      Но здесь стоит оговориться: List<? extends Object> — не reifiable, а List<?> — reifiable


------------------------------------------------------------------------------------------------------------------------
Почему в примере ниже нельзя создать параметризованный Exception?

        class MyException<T> extends Exception {      // Generic class may not extend ‘java.lang.Throwable’
           T t;
        }

Ответ
Каждое catch выражение в try-catch проверяет тип полученного исключения
во время выполнения программы (что равносильно instanceof),  соответственно, тип должен быть Reifiable.
Поэтому Throwable и его подтипы не могут быть параметризованы.

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
